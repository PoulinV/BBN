#define FUNC(x,a,i,g,E_O,Z_x,z_0) ((*func)(x,a,i,g,E_O,Z_x,z_0))

#include <iostream>
using namespace std;
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <fstream>
#define EPS 1.0e-1
#define JMAX 10
#include <sstream>
#include "../Include/Abondancev5_2.h"
/******Programme*******/
/******Calcul graphe tau-zeta pour Deutérium AVEC PRODUCTION via Helium, spectre non standard******/
/*****ATTENTION - vérifier Abondancev5_2.h pour savoir quel spectre est utilisé*****/
/****** Pour les intervalles des abondances, voir arxiv:1307.6955*****/
int main()
{
    double Y_De_max_cyburt =1*pow(10,-4), Y_De_max_standard = 3.48*pow(10,-5),Y_De_min_cyburt=1*pow(10,-5),Y_De_min_standard = 2.56*pow(10,-5) ;
    float Emin[19];
    Emin[0] = 2.47 ; Emin[1] = 7.25 ; Emin[2] = 10.95 ;  Emin[3] = 8.725 ; Emin[4] = 9.98 ; Emin[5] = 22.28 ; Emin[6] = 23.05 ; Emin[7] = 1.59; Emin[8] = 5.61 ; Emin[9] = 9.31 ; Emin[10] = 7.08 ; Emin[11] = 10.68 ; Emin[12] = 22.17 ; Emin[13] = 21.4 ; Emin[14] = 2.23 ; Emin[15] = 19.82 ; Emin[16] = 20.58 ; Emin[17] = 23.85 ; Emin[18] = 26.08 ;
    //~ for(int i=0;i<14;i++)Emin[i]+=0.;
    float T;
    double T_0 = 2.7255*0.862*pow(10,-10);
    double H_0 = 2.187*pow(10,-18);
    double H_r = 2.187*pow(10,-18)*pow((1+7/8*pow(4/11,4/3)*3.046)*5.46*pow(10,-5),0.5), Z_x = pow(10,-6) , n_y_0=3.154*pow(10,-30) , E_0 ;
    double omega_b = 0.02225;
    double tau_n = 880.3, tau_n_0 = 880.3;
    double z,count1,count2,count3,Y_0 = 2.53*pow(10,-5)*pow(omega_b/0.02273,-1.62)*pow(tau_n/tau_n_0,0.41),Y_De,A,B;
    cout << " Y_2H_0 = " << Y_0 << endl;
    float tau, Ex , Ec, s,s2;
    double pi=3.14159;

    // ofstream output_De("results_Graphe_De_standard_sans_production.dat");
    ofstream output_De("../OutputDe/results_Graphe_De_non_standard_4MeV_trois_iterations.dat");
    ifstream file("../TableIntegraleSpectre/results_Reinj_Monochromatique_Destruc2H_4MeV.dat");
    ifstream file2("../TableIntegraleSpectre/results_deux_interactions_Destruc2H_4MeV.dat");
    fill_table_from_file(file,vector_z_s2H_destruc,vector_s2H_destruc);
    fill_table_from_file(file2,vector_z_s2H_destruc_deux_iterations,vector_s2H_destruc_deux_iterations);
    //for(int i=0;i<vector_z_s2H_destruc_deux_iterations.size();i++)cout<< vector_z_s2H_destruc_deux_iterations[i]<< " "<< vector_z_s2H_destruc_deux_iterations[i] << endl;
    // ofstream output_De("results_Graphe_De_sans_reinj_10-4.dat");
    //~ ofstream output_He("results_Graphe_He.dat");
    //~ ofstream output_Be("results_Graphe_Be.dat");
    double M_x,E_max;
    M_x=8;
    E_0=M_x/2;
    //~ T=1*pow(10,-1);
    int x =2;
    Attribution_avec_correction(x);
    tau=pow(10,4);double tau_moy=pow(10,6);double tau_moy2=pow(10,8);double tau_max=pow(10,10);
    //~ double T_min = 0.511*0.511/(1.6*22);
    double T_max = pow(tau_max*(2*H_r),-0.5)*T_0;
    //~ double T_max = 0.511*0.511/(2.2*22);
    //~ tau=pow(T_min/T_0,-2)/(2*H_r);tau_max=pow(T_max/T_0,-2)/(2*H_r);
    cout << " tau min = " << tau << " tau max = "<< tau_max << endl;
    double z_max = 35000;
    double h_moy = 100;
    double h_moy2 = 2*h_moy;
    double h_max = 3*h_moy;

    double Delta = (tau_moy-tau)/h_moy;
    double Delta2 = (tau_moy2-tau_moy)/h_moy;
    double Delta3 = (tau_max-tau_moy2)/h_moy;
    cout << "Delta 1 = " << Delta << " Delta 2 = " << Delta2 << " Delta 3 = " << Delta3 << endl;
    //~ tau=tau_moy;
    //~ double test;
    for(int h=0;h<h_max;h++)
    {
        if(h==h_moy){Delta=Delta2;tau=tau_moy;}
        if(h==h_moy2){Delta=Delta3;tau=tau_moy2;}
        if(h>1)tau+=Delta;
        T=pow(0.2*tau*(2*H_r),-0.5)*T_0;
        z = T/T_0 - 1;
        count1 = 0;count2=0;count3=0;
        Ex = 0.261121/(80*T_0*(1+z)), Ec = 0.261121/(22*T_0*(1+z));

        cout << "****************h = "<<h<<"  tau = "<<tau<<"***************"<<endl;
        cout << "Ex = " << Ex << " Ec = " << Ec << " T= " << T << " tau = " << tau <<" z = "<< z << endl;
        //~ for(int n = 1 ; n<10;n++)cout << trapzd(func_x,z_max,z,z,n,14,E_0,Z_x)<<endl;
        //~ cout << qsimp(func_x,z_max,z,z,14,E_0,Z_x)<<endl;
        A = qsimp_Z(K_Perte_non_standard,z_max,z,z,14,E_0,0,z);
        // A = qsimp(K_Perte,z_max,z,z,14,E_0,0,z);

        for(int l=10;l>1;l--)
          {
            for(double k=1;k<10;k+=0.1)
              {
                Z_x=k*pow(10,-l);

                //~ cout << " A = " << A << " B = " << B << endl;
                //~ cout << "Gain = " << S_Gain(z,z,14,z,E_0,Z_x)<< endl;
                Y_De=exp(-Z_x*n_y_0/(E_0*H_r*tau)*A)*(Y_0);
                // Y_De=exp(-1*Z_x*n_y_0/(E_0*H_r*tau)*A)*Y_0;
                //~ cout << "Y_De = " << Y_De << endl;

                    if(Y_De<Y_De_min_standard&& count2 == 0)
                      {
                        // output_De << Z_x <<"  "<< tau <<"  "<<Y_De << "  " << 2 << endl;
                        // cout << " Y_De = " << Y_De << " A = " << A << " B = " << B << "  " <<  2 <<  endl;
                        output_De <<tau <<"  "<<  Z_x << "  " << endl;
                        count2++;
                        cout << "count 2 = " << count2<<endl;
                        count3++;
                      }
                              if(count2==1){break;}
                      // if(count1==2 && count2==1)break;
                      // else if(count2==1&&count1==0)break;

                  }
                          if(count2 == 1)break;
                    // if(count1==2 && count2==1)break;
                    // else if(count2==1&&count1==0)break;

                  }
          }
    output_De.close();
    //~ output_He.close();
    //~ output_Be.close();
    return 0;
}
